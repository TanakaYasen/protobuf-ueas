package main

import (
	"log"
	"path/filepath"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
)

const hRpcStubCodeGoServer = `
// This file is generated by tool, DONT EDIT IT
// Source: [[{{.SourceFile}}]]
package {{.PackageName}}

import (
	proto "github.com/gogo/protobuf/proto"
)

type IClientConnection interface {
	SendPackage([]byte)
	Close()
}

{{range .ServerStubs}}

type {{.ServiceName}}Dispatcher struct {
	callbacks map[string]func(data []byte) []byte
	handler {{.ServiceName}}DispatcherImpl
}

func (d *{{.ServiceName}}Dispatcher) OnHandlePkg(msg []byte) {
	req := Package{}
	if err := proto.Unmarshal(msg, &req); err != nil {
		return
	}
	if cb, ok := d.callbacks[req.Route]; ok {
		rp := cb(req.Data)
		if len(rp) == 0 {
			return
		}
		resp := Package{
			Route:     req.Route,
			SessionId: req.SessionId,
			ErrCode:   0,
			Data:      rp,
		}
		rd, err := proto.Marshal(&resp)
		if err != nil {
			return
		}
		conn.SendPackage(rd)
	}
}

type {{.ServiceName}}DispatcherImpl interface {
	// msgs
	{{- range .SvMethods}}
	{{.MethodName}} ({{if not (eq .ReqMsg "Void") }} {{.ReqMsg}} {{end}}) {{if not (eq .RespMsg "Void") }}{{.RespMsg}}{{ end }}
	{{- end}}
}


func New{{.ServiceName}}Dispatcher(dis {{.ServiceName}}DispatcherImpl, conn IClientConnection) *{{.ServiceName}}Dispatcher {
	var r = new({{.ServiceName}}Dispatcher)
	r.handler = dis
	r.conn = conn
	r.callbacks = map[string]func([]byte)[]byte {
	{{range .SvMethods}}
		"{{- .MethodName}}": func(b []byte) []byte {
			var request = {{.ReqMsg}}{}
			err := proto.Unmarshal(b, &request)
			if err != nil {
				return nil
			}
			{{- if not (eq .RespMsg "Void") }} 
			var response = r.handler.{{.MethodName}}(request)
			r.handler.{{.MethodName}}(request)
			d, _ := proto.Marshal(&response)
			return d
			{{ else }}
			r.handler.{{.MethodName}}(request)
			return nil
			{{- end }}
		},
	{{- end}}
	}
	return r
}
{{end}}
`

const hRpcStubCodeGoClient = `
// This file is generated by tool, DONT EDIT IT
// Source: [[{{.SourceFile}}]]
package {{.PackageName}}

import (
	proto "github.com/gogo/protobuf/proto"
)

type IConn interface {
	SendPackage([]byte)
}

{{range .ClientStubs}}

type {{.ServiceName}}Dispatcher struct {
	callbacks map[string]func(data []byte) []byte
	handler {{.ServiceName}}DispatcherImpl
}

func (d *{{.ServiceName}}Dispatcher) OnHandlePkg(conn IConn, msg []byte) {
	req := Package{}
	if err := proto.Unmarshal(msg, &req); err != nil {
		return
	}
	if cb, ok := d.callbacks[req.Route]; ok {
		rp := cb(req.Data)
		if len(rp) == 0 {
			return
		}
		resp := Package{
			Route:     req.Route,
			SessionId: req.SessionId,
			ErrCode:   0,
			Data:      rp,
		}
		rd, err := proto.Marshal(&resp)
		if err != nil {
			return
		}
		conn.SendPackage(rd)
	}
}

type {{.ServiceName}}DispatcherImpl interface {
	// msgs
	{{- range .SvMethods}}
	{{.MethodName}} ({{if not (eq .ReqMsg "Void") }} {{.ReqMsg}} {{end}}) {{if not (eq .RespMsg "Void") }}{{.RespMsg}}{{ end }}
	{{- end}}
}
	

func New{{.ServiceName}}Dispatcher(dis {{.ServiceName}}DispatcherImpl) *{{.ServiceName}}Dispatcher {
	var r = new({{.ServiceName}}Dispatcher)
	r.handler = dis
	r.callbacks = map[string]func([]byte)[]byte {
	{{range .SvMethods}}
		"{{- .MethodName}}": func(b []byte) []byte {
			var request = {{.ReqMsg}}{}
			err := proto.Unmarshal(b, &request)
			if err != nil {
				return nil
			}
			{{- if not (eq .RespMsg "Void") }} 
			var response = r.handler.{{.MethodName}}(request)
			r.handler.{{.MethodName}}(request)
			d, _ := proto.Marshal(&response)
			return d
			{{ else }}
			r.handler.{{.MethodName}}(request)
			return nil
			{{- end }}
		},
	{{- end}}
	}
	return r
}
{{end}}
`

type ServiceMethod struct {
	MethodName string
	ReqMsg     string
	RespMsg    string
}

type ServiceDesc struct {
	ServiceName string
	SvMethods   []ServiceMethod
}
type GenRPC struct {
	PackageName string
	SourceFile  string
	ClientStubs []*ServiceDesc
	ServerStubs []*ServiceDesc
}

func generateGoRpc(gen *protogen.Plugin, file *protogen.File) {
	baseFilename := filepath.Base(file.GeneratedFilenamePrefix)
	filename := baseFilename + ".server.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	pdata := &GenRPC{
		PackageName: string(file.GoPackageName),
		SourceFile:  file.Desc.Path(),
	}

	for _, s := range file.Services {
		pdata.ServerStubs = append(pdata.ServerStubs, &ServiceDesc{ServiceName: string(s.Desc.Name())})
		last := pdata.ServerStubs[len(pdata.ServerStubs)-1]
		for _, m := range s.Methods {
			last.SvMethods = append(last.SvMethods, ServiceMethod{
				MethodName: m.GoName,
				ReqMsg:     string(m.Input.Desc.Name()),
				RespMsg:    string(m.Output.Desc.Name()),
			})
		}
	}

	templ, err := template.New("rpcstub").Parse(hRpcStubCodeGoServer)
	if err != nil {
		log.Fatalln(err)
		return
	}
	err = templ.Execute(g, pdata)
	if err != nil {
		log.Fatalln(err)
		return
	}

	filename = baseFilename + ".client.go"
	g = gen.NewGeneratedFile(filename, file.GoImportPath)

	templ, err = template.New("rpcstub").Parse(hRpcStubCodeGoClient)
	if err != nil {
		log.Fatalln(err)
		return
	}
	err = templ.Execute(g, pdata)
	if err != nil {
		log.Fatalln(err)
		return
	}
}
