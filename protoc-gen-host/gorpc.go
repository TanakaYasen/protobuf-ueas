package main

import (
	"log"
	"path/filepath"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
)

const hRpcStubCodeGoServer = `
// This file is generated by tool, DONT EDIT IT
// Source: [[{{.SourceFile}}]]
package {{.PackageName}}

import (
	proto "github.com/gogo/protobuf/proto"
)

type IClientConnection interface {
	SendPackage([]byte)
	Close()
}

{{range .ServerStubs}}

// type implements DispatcherImpl is the real reactor
//     and is born for New{{.ServiceName}}Dispatcher
type {{.ServiceName}}DispatcherImpl interface {
	{{- range .SvMethods}}
	{{.MethodName}} ({{if not (eq .ReqMsg "Void") }} {{.ReqMsg}} {{end}}) {{if not (eq .RespMsg "Void") }}{{.RespMsg}}{{ end }}
	{{- end}}
}

type Svr{{.ServiceName}}Dispatcher struct {
	callbacks map[string]func(data []byte) []byte
	handler {{.ServiceName}}DispatcherImpl
	connection IClientConnection
}

func (d *Svr{{.ServiceName}}Dispatcher) OnHandlePkg(msg []byte) {
	req := Package{}
	if err := proto.Unmarshal(msg, &req); err != nil {
		return
	}
	if cb, ok := d.callbacks[req.Route]; ok {
		rp := cb(req.Data)
		if len(rp) == 0 {
			return
		}
		resp := Package{
			Route:     req.Route,
			SessionId: req.SessionId,
			ErrCode:   0,
			Data:      rp,
		}
		rd, err := proto.Marshal(&resp)
		if err != nil {
			return
		}
		d.connection.SendPackage(rd)
	}
}
	
func New{{.ServiceName}}Dispatcher(dis {{.ServiceName}}DispatcherImpl, conn IClientConnection) *Svr{{.ServiceName}}Dispatcher {
	var ret = new(Svr{{.ServiceName}}Dispatcher)
	ret.handler = dis
	ret.connection = conn
	//hard-coded router
	ret.callbacks = map[string]func([]byte)[]byte {
	{{range .SvMethods}}
		"{{- .MethodName}}": func(b []byte) []byte {
			var request = {{.ReqMsg}}{}
			err := proto.Unmarshal(b, &request)
			if err != nil {
				return nil
			}
			{{- if not (eq .RespMsg "Void") }} 
			var response = ret.handler.{{.MethodName}}(request)
			ret.handler.{{.MethodName}}(request)
			d, _ := proto.Marshal(&response)
			return d
			{{ else }}
			ret.handler.{{.MethodName}}(request)
			return nil
			{{- end }}
		},
	{{- end}}
	}
	return ret
}
{{end}}
`

const hRpcStubCodeGoClient = `
// This file is generated by tool, DONT EDIT IT
// Source: [[{{.SourceFile}}]]
package {{.PackageName}}

import (
	proto "github.com/gogo/protobuf/proto"
)

type IServerConnection interface {
	SendPackage([]byte)
	Close()
}


{{range .ClientStubs}}

type Cli{{.ServiceName}}Dispatcher struct {
	callbacks map[string]func(data []byte)
	handler {{.ServiceName}}DispatcherImpl
	connection IServerConnection
}

func (d *Cli{{.ServiceName}}Dispatcher) OnHandlePkg(msg []byte) {
	req := Package{}
	if err := proto.Unmarshal(msg, &req); err != nil {
		return
	}
	if cb, ok := d.callbacks[req.Route]; ok {
		cb(req.Data)
	}
}

type {{.ServiceName}}DispatcherImpl interface {
	{{- range .SvMethods}}
	{{.MethodName}} ({{if not (eq .ReqMsg "Void") }} {{.ReqMsg}} {{end}}) {{if not (eq .RespMsg "Void") }}{{.RespMsg}}{{ end }}
	{{- end}}
}
	

func New{{.ServiceName}}Dispatcher(dis {{.ServiceName}}DispatcherImpl, conn IServerConnection) *Cli{{.ServiceName}}Dispatcher {
	var ret = new(Cli{{.ServiceName}}Dispatcher)
	ret.handler = dis
	ret.connection = conn
	ret.callbacks = map[string]func([]byte) {
	{{- range .SvMethods}}
		"{{- .MethodName}}": func(b []byte) {
			var request = {{.ReqMsg}}{}
			err := proto.Unmarshal(b, &request)
			if err != nil {
				return
			}
			ret.handler.{{.MethodName}}(request)
		},
	{{- end}}
	}
	return ret
}
{{end}}
`

type ServiceMethod struct {
	MethodName string
	ReqMsg     string
	RespMsg    string
}

type ServiceDesc struct {
	ServiceName string
	SvMethods   []ServiceMethod
}
type GenRPC struct {
	PackageName string
	SourceFile  string
	ClientStubs []*ServiceDesc
	ServerStubs []*ServiceDesc
}

func generateGoRpc(gen *protogen.Plugin, file *protogen.File) {
	baseFilename := filepath.Base(file.GeneratedFilenamePrefix)
	filename := baseFilename + ".server.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	pdata := &GenRPC{
		PackageName: string(file.GoPackageName),
		SourceFile:  file.Desc.Path(),
	}

	for _, s := range file.Services {
		if strings.Contains(string(s.Desc.Name()), "C2S") {
			ele := &ServiceDesc{ServiceName: string(s.Desc.Name())}
			for _, m := range s.Methods {
				ele.SvMethods = append(ele.SvMethods, ServiceMethod{
					MethodName: m.GoName,
					ReqMsg:     string(m.Input.Desc.Name()),
					RespMsg:    string(m.Output.Desc.Name()),
				})
			}
			pdata.ServerStubs = append(pdata.ServerStubs, ele)
		} else {
			ele := &ServiceDesc{ServiceName: string(s.Desc.Name())}
			for _, m := range s.Methods {
				ele.SvMethods = append(ele.SvMethods, ServiceMethod{
					MethodName: m.GoName,
					ReqMsg:     string(m.Input.Desc.Name()),
					RespMsg:    string(m.Output.Desc.Name()),
				})
			}
			pdata.ClientStubs = append(pdata.ClientStubs, ele)
		}
	}

	templ, err := template.New("rpcstub").Parse(hRpcStubCodeGoServer)
	if err != nil {
		log.Fatalln(err)
		return
	}
	err = templ.Execute(g, pdata)
	if err != nil {
		log.Fatalln(err)
		return
	}

	filename = baseFilename + ".client.go"
	g = gen.NewGeneratedFile(filename, file.GoImportPath)

	templ, err = template.New("rpcstub").Parse(hRpcStubCodeGoClient)
	if err != nil {
		log.Fatalln(err)
		return
	}
	err = templ.Execute(g, pdata)
	if err != nil {
		log.Fatalln(err)
		return
	}
}
