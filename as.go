package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const hTemplCode = `
// This file is generated by tool, DONT EDIT IT
// Source: [[{{.SourceFile}}]]

#include <cstdlib>
#include <cstdint>
#include <string>
#include <vector>

//as decl
class asIScriptEngine;	//engine
class asIScriptGeneric;	//gen

namespace {{.PackageName}} {

{{ define "message" }}
#pragma region "{{.ClassName}}"
class {{.ClassName}} {
	static constexpr int MaxField = {{.DirtyCount}};
public:
	{{range .Enums}}
	enum {{.DefName}}{ 
		{{range .Values}}{{.EName}} = {{.ENum}},
		{{end}}
	};
	{{end}}

	{{if gt (len .Nested) 0}}
	//nested messages
	{{range .Nested}}
		{{ template "message" .}}
	{{end}}
	{{end}}

	{{range .Fields}}
	{{.Getter}}
	{{.Setter}}
	{{end}}

	{{.ClassName}}();
	explicit {{.ClassName}}(std::string_view);
	std::string Serialize() const;
	bool Unserialize(const uint8_t *_data, size_t len);
	bool IsValid() const { return Valid; }
	static void RegisterToAngelScript(asIScriptEngine *engine);

private:
	bool 	Valid;
	{{if gt .DirtyCount 0}}
	uint64_t	DirtyMask[(MaxField+63)/64];
	{{end}}
	
	{{range .Fields}}
	{{.TypeName}} {{.FieldName}}_{{if .DefaultValue}} = {{.DefaultValue}}{{end}};
	{{end}}
};
#pragma endregion
{{ end }}

{{ range .ClassDefinations}}
	{{ template "message" . }}
{{end}}

void RegisterToAngelScript(asIScriptEngine *engine);

}
`

const cppTemplCode = `
// This file is generated by tool, DONT EDIT IT
// Source: [[{{.SourceFile}}]]

#include "{{.ProtoName}}.h"
#include "../runtime/wire.h"
#include <angelscript.h>


namespace {{.PackageName}} {
	{{ range .ClassDefinations}}

	#pragma region "{{.ClassName}}"
	{{.ClassName}}::{{.ClassName}}() {
		{{if gt .DirtyCount 0}}
		::memset(DirtyMask, 0, (MaxField+63)/64);
		{{end}}
	}
	{{.ClassName}}::{{.ClassName}}(std::string_view v):Valid(true) {
		if (!Unserialize((const uint8_t*)v.data(), v.length())) {
			Valid = false;
		}
	}
	std::string {{.ClassName}}::Serialize() const {
	{{if gt (len .Fields) 0}}
		WireEncoder encoder;
		{{range .Fields}} {{/* encoder.{{.EncodeMethod}}({{.Number}}, {{.FieldName}}_);  */}}
		{{.EncodeCode}}
		{{end}}
		return encoder.Dump();
	{{else}}
		return std::string{};
	{{end}}
	}

	bool {{.ClassName}}::Unserialize(const uint8_t *_data, size_t len) {
	{{if gt (len .Fields) 0}}
		uint64_t fn = 0;
		WireDecoder decoder(_data, len);
		while ((fn = decoder.ReadTag()) && decoder.IsOk()) {
			switch(fn) { {{range .Fields}}
			case {{.Number}}: {{/* {{.FieldName}}_ = decoder.{{.DecodeMethod}}(); */}}
				{{.DecodeCode}}
				break;{{end}}
			default:
				break;
			}
		}
		return decoder.IsOk();
	{{else}}
		return true;
	{{end}}
	}

	void {{.ClassName}}::RegisterToAngelScript(asIScriptEngine *engine) {
	}
	{{end}}

	#pragma endregion

	void RegisterToAngelScript(asIScriptEngine *engine) {
	{{ range .ClassDefinations}}
		{{.ClassName}}::RegisterToAngelScript(engine);
	{{end}}
	}

}
`

var asprotoNative = map[protoreflect.Kind]typeMapper{
	protoreflect.BoolKind:   {"bool", "false", "DecodeBool", "DecodeRepBool", "EncodeBool", "EncodeRepBool"},
	protoreflect.Int32Kind:  {"int32_t", "0", "DecodeInt32", "DecodeRepInt32", "EncodeInt32", "EncodeRepInt32"},
	protoreflect.Sint32Kind: {"int32_t", "0", "DecodeSint32", "DecodeRepSint32", "EncodeSint32", "EncodeRepSint32"},
	protoreflect.Uint32Kind: {"uint32_t", "0", "DecodeUint32", "DecodeRepUint32", "EncodeUint32", "EncodeRepUint32"},
	protoreflect.Int64Kind:  {"int64_t", "0", "DecodeInt64", "DecodeRepInt64", "EncodeInt64", "EncodeRepInt64"},
	protoreflect.Sint64Kind: {"int64_t", "0", "DecodeSint64", "DecodeRepSint64", "EncodeSint64", "EncodeRepSint64"},
	protoreflect.Uint64Kind: {"uint64_t", "0", "DecodeUint64", "DecodeRepUint64", "EncodeUint64", "EncodeRepUint64"},

	protoreflect.Sfixed32Kind: {"int32_t", "0", "DecodeSfixed32", "DecodeRepSfixed32", "EncodeSfixed32", "EncodeRepSfixed32"},
	protoreflect.Fixed32Kind:  {"uint32_t", "0", "DecodeFixed32", "DecodeRepFixed32", "EncodeFixed32", "EncodeRepFixed32"},
	protoreflect.Sfixed64Kind: {"int64_t", "0", "DecodeSfixed64", "DecodeRepSfixed64", "EncodeSfixed64", "EncodeRepSfixed64"},
	protoreflect.Fixed64Kind:  {"uint64_t", "0", "DecodeFixed64", "DecodeRepFixed64", "EncodeFixed64", "EncodeRepFixed64"},

	protoreflect.FloatKind:  {"float", "0.f", "DecodeFloat", "DecodeRepFloat", "EncodeFloat", "EncodeRepFloat"},
	protoreflect.DoubleKind: {"double", "0.0", "DecodeDouble", "DecodeRepDouble", "EncodeDouble", "EncodeRepDouble"},
	protoreflect.StringKind: {"std::string", "", "DecodeString", "DecodeRepString", "EncodeString", "EncodeRepString"},
	protoreflect.BytesKind:  {"std::vector<uint8_t>", "", "DecodeByte", "", "EncodeBytes", ""},
}

func asparseMessageField(classDef *ClassDef, fd protoreflect.FieldDescriptor, scopeTracker *scopeResolver) {
	var isRepeated = fd.Cardinality() == protoreflect.Repeated
	var formater string = "%s"
	if isRepeated {
		formater = "std::vector<%s>"
	}
	fieldInfo := &FieldInfo{
		FieldName:  string(fd.Name()),
		Number:     uint64(fd.Number()),
		DirtyIndex: -1,
	}

	n, ok := asprotoNative[fd.Kind()]
	if ok {
		fieldInfo.TypeName = fmt.Sprintf(formater, n.cppType)
		if isRepeated {
			fieldInfo.EncodeMethod = n.encodeRepMethod
			fieldInfo.DecodeMethod = n.decodeRepMethod
			fieldInfo.EncodeCode = fmt.Sprintf("encoder.%s(%d, %s_);", n.encodeRepMethod, fieldInfo.Number, fieldInfo.FieldName)
			fieldInfo.DecodeCode = fmt.Sprintf("decoder.%s(%s_);", n.decodeRepMethod, fieldInfo.FieldName)
		} else {
			fieldInfo.EncodeMethod = n.encodeMethod
			fieldInfo.DecodeMethod = n.decodeMethod
			fieldInfo.EncodeCode = fmt.Sprintf("encoder.%s(%d, %s_);", n.encodeMethod, fieldInfo.Number, fieldInfo.FieldName)
			fieldInfo.DecodeCode = fmt.Sprintf("%s_ = decoder.%s();",
				fieldInfo.FieldName, n.decodeMethod)
			fieldInfo.DefaultValue = n.zeroValue
		}
	} else {
		/*
			if fd.Kind() == protoreflect.MessageKind {
				if isRepeated {
					fieldInfo.EncodeCode = fmt.Sprintf("for (const auto &v: %s_){ encoder.EncodeSubmessage(%d, v); }", fieldInfo.FieldName, fieldInfo.Number)
					fieldInfo.DecodeCode = fmt.Sprintf("{auto v = decoder.DecodeSubmessage();  %s_.emplace_back(); %s_.back().Unserialize((const uint8_t*)v.data(), v.length()); }",
						fieldInfo.FieldName, fieldInfo.FieldName)
				} else {
					fieldInfo.EncodeCode = fmt.Sprintf("encoder.EncodeSubmessage(%d, %s_);", fieldInfo.Number, fieldInfo.FieldName)
					fieldInfo.DecodeCode = fmt.Sprintf("{auto v = decoder.DecodeSubmessage(); %s_.Unserialize((const uint8_t*)v.data(), v.length()); }", fieldInfo.FieldName)
				}
				cppTypeName := scopeTracker.DescopedName(string(fd.Message().FullName()))
				fieldInfo.TypeName = fmt.Sprintf(formater, cppTypeName)
			}
		*/
		if fd.Kind() == protoreflect.MessageKind {
			if isRepeated {
				fieldInfo.EncodeCode = fmt.Sprintf("for (const auto &v: %s_){ encoder.EncodeSubmessage(%d, v); }", fieldInfo.FieldName, fieldInfo.Number)
				fieldInfo.DecodeCode = fmt.Sprintf("{ decoder.DecodeRepSubmessage(%s_); }",
					fieldInfo.FieldName)
			} else {
				fieldInfo.EncodeCode = fmt.Sprintf("encoder.EncodeSubmessage(%d, %s_);", fieldInfo.Number, fieldInfo.FieldName)
				fieldInfo.DecodeCode = fmt.Sprintf("{auto v = decoder.DecodeSubmessage(); %s_.Unserialize((const uint8_t*)v.data(), v.length()); }", fieldInfo.FieldName)
			}
			cppTypeName := scopeTracker.DescopedName(string(fd.Message().FullName()))
			fieldInfo.TypeName = fmt.Sprintf(formater, cppTypeName)
		}

		if fd.Kind() == protoreflect.EnumKind {

			cppTypeName := scopeTracker.DescopedName(string(fd.Enum().FullName()))
			fieldInfo.TypeName = fmt.Sprintf(formater, cppTypeName)

		} else {

		}
	}

	capName := strings.ToUpper(fieldInfo.FieldName[0:1]) + fieldInfo.FieldName[1:]

	if isRepeated {

		switch fd.Kind() {
		case protoreflect.BoolKind,
			protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind,
			protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind,
			protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
			protoreflect.Sfixed64Kind, protoreflect.Fixed64Kind,
			protoreflect.FloatKind, protoreflect.DoubleKind:
			fieldInfo.Getter = fmt.Sprintf("%s Get%s() const { return %s_; }", n.cppType, capName, fieldInfo.FieldName)
			fieldInfo.Setter = fmt.Sprintf("void Set%s(%s value) { %s_ = value; }", capName, n.cppType, fieldInfo.FieldName)

		case protoreflect.StringKind:
			fieldInfo.Getter = fmt.Sprintf("std::string Get%s() const { return %s_;}", capName, fieldInfo.FieldName)
			fieldInfo.Setter = fmt.Sprintf("void Set%s(const std::string &value) { %s_ = value; }", capName, fieldInfo.FieldName)
		case protoreflect.BytesKind:
			fieldInfo.Getter = fmt.Sprintf("std::vector<uint8_t> Get%s() const { return %s_; }", capName, fieldInfo.FieldName)
			fieldInfo.Setter = fmt.Sprintf("void Set%s(const std::vector<uint8_t> &value) { %s_ = value; }", capName, fieldInfo.FieldName)
		case protoreflect.MessageKind:
			fieldInfo.Getter = fmt.Sprintf("const auto &Get%s() const ", capName)
			fieldInfo.Setter = fmt.Sprintf("auto& Mutable%s(const std::string &value) ", capName)
		}
	} else {
		switch fd.Kind() {
		case protoreflect.BoolKind,
			protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind,
			protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind,
			protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
			protoreflect.Sfixed64Kind, protoreflect.Fixed64Kind,
			protoreflect.FloatKind, protoreflect.DoubleKind:

			fieldInfo.DirtyIndex = classDef.DirtyCount
			classDef.DirtyCount++

			fieldInfo.Getter = fmt.Sprintf("%s Get%s() const { return %s_; }", n.cppType, capName, fieldInfo.FieldName)
			fieldInfo.Setter = fmt.Sprintf("void Set%s(%s value) { %s_ = value; DirtyMask[%d] |= 0x%X; }",
				capName, n.cppType, fieldInfo.FieldName, fieldInfo.DirtyIndex/8, (uint64)(1<<(fieldInfo.DirtyIndex%8)))

		case protoreflect.StringKind:
			fieldInfo.Getter = fmt.Sprintf("std::string Get%s() const { return %s_;}", capName, fieldInfo.FieldName)
			fieldInfo.Setter = fmt.Sprintf("void Set%s(const std::string &value) { %s_ = value; }", capName, fieldInfo.FieldName)

		case protoreflect.BytesKind:
			fieldInfo.Getter = fmt.Sprintf("std::vector<uint8_t> Get%s() const { return %s_; }", capName, fieldInfo.FieldName)
			fieldInfo.Setter = fmt.Sprintf("void Set%s(const std::vector<uint8_t> &value) { %s_ = value; }", capName, fieldInfo.FieldName)

		case protoreflect.MessageKind:
			fieldInfo.Getter = fmt.Sprintf("const auto &Get%s() const ", capName)
			fieldInfo.Setter = fmt.Sprintf("auto& Mutable%s(const std::string &value) ", capName)
		}

	}
	classDef.Fields = append(classDef.Fields, fieldInfo)
}

func asparseEnum(e *protogen.Enum) *EnumDef {
	var res = new(EnumDef)
	res.DefName = string(e.Desc.Name())
	for _, v := range e.Values {
		res.Values = append(res.Values, EnumValue{string(v.Desc.Name()), 0})
	}
	return res
}

func asparseMessageClass(msg *protogen.Message, scopeTracker *scopeResolver) *ClassDef {
	var newClass *ClassDef = new(ClassDef)
	newClass.ClassName = string(msg.Desc.FullName().Name())

	scopeTracker.ScopeIn(newClass.ClassName)

	for _, subMessage := range msg.Messages {
		var subClass = asparseMessageClass(subMessage, scopeTracker)
		newClass.Nested = append(newClass.Nested, subClass)
	}

	for _, subEnum := range msg.Enums {
		newClass.Enums = append(newClass.Enums, asparseEnum(subEnum))
	}

	for _, field := range msg.Fields {
		asparseMessageField(newClass, field.Desc, scopeTracker)
	}

	scopeTracker.ScopeOut()
	return newClass
}

func generateAs(gen *protogen.Plugin, file *protogen.File) {
	pathStr := file.Desc.Path()
	var baseName string = path.Base(file.Desc.Path())
	baseName = baseName[:len(baseName)-len(filepath.Ext(baseName))]

	OutputDir := path.Join("generated")
	outputHeader := filepath.Join(OutputDir, baseName+".h")
	outputCpp := filepath.Join(OutputDir, baseName+".cpp")
	scoper := new(scopeResolver)

	pdata := ParsedStruct{
		SourceFile:  pathStr,
		ProtoName:   baseName,
		PackageName: *file.Proto.Package,
		HIncludes: []string{
			"CoreMinimal.h",
			"Container/TArray.h",
			"Container/TMap.h",
		},
		CppIncludes: []string{
			baseName + ".h",
			"uewire.h",
		},
	}

	outputCppFile, err := os.OpenFile(outputCpp, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		log.Println(err.Error())
		return
	}
	defer outputCppFile.Close()

	outputHeaderFile, err := os.OpenFile(outputHeader, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		log.Println(err.Error())
		return
	}
	defer outputHeaderFile.Close()

	scoper.ScopeIn(*file.Proto.Package)
	for _, msg := range file.Messages {
		pdata.ClassDefinations = append(pdata.ClassDefinations, asparseMessageClass(msg, scoper))
	}
	scoper.ScopeOut()

	templ, err := template.New("ash").Parse(hTemplCode)
	if err != nil {
		log.Fatalln(err)
		return
	}
	templ.Execute(outputHeaderFile, pdata)

	templ, err = templ.New("ascpp").Parse(cppTemplCode)
	if err != nil {
		log.Fatalln(err)
		return
	}
	templ.Execute(outputCppFile, pdata)

}
