package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"path/filepath"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var ueasHeaderTempl string = `
// this file is generated by tool
// DONT EDIT IT MANUALLY
// SOURCE [[{{.SourceFile}}]]

# pragma once

#include "CoreMinimal.h"
#include "Container/TArray.h"
#include "Container/TMap.h"

namespace {{.PackageName}} {
	
	{{range .ClassDefinations}}
	USTRUCT(BlueprintType)
	struct FPb_{{ .ClassName }} {
	public:
		{{- range .Fields}}
		UPROPERTY(BlueprintReadWrite)
		{{.TypeName}} {{.FieldName}}{{if .DefaultValue}} = {{.DefaultValue}}{{end}};
		{{end}}

		bool _Valid = true;
		ustring Serialize() const;
		bool Unserialize(const uint8*, size_t);
	};
	{{end}}
}

`

var ueasCppTempl string = `
// this file is generated by tool
// DONT EDIT IT MANUALLY
// SOURCE: [[{{.SourceFile}}]]

#include "{{.ProtoName}}.h"
#include "uewire.h"

namespace {{.PackageName}} {
{{range .ClassDefinations}}

#pragma region "{{.ClassName}}"

	ustring FPb_{{.ClassName}}::Serialize() const {
{{- if gt (len .Fields) 0}}
		WireEncoder encoder;
		{{- range .Fields}}{{if .EncodeCode}}{{.EncodeCode}}{{else}}encoder.{{.EncodeMethod}}({{.Number}}, {{.FieldName}}){{end}};
		{{- end}}
		return encoder.Dump();
{{- else}}
		return ustring{};
{{- end}}
	}
	bool FPb_{{.ClassName}}::Unserialize(const uint8* data, size_t len) {
{{- if gt (len .Fields) 0}}
		uint64 fn = 0;
		WireDecoder decoder(data, len);
		while ((fn = decoder.ReadTag()) && decoder.IsOk()) {
			switch(fn) { {{range .Fields}}
			case {{.Number}}:
				{{if .DecodeCode}}{{.DecodeCode}}{{else}}{{.FieldName}} = {{.DecodeMethod}}();{{end}}
				break;{{end}}
			default:
				break;
			}
		}
		return _Valid = decoder.Ok();
{{- else}}
		return true;
{{- end}}
	}
#pragma endregion //"{{.ClassName}}"
{{end}}
}
`

var ueasprotoNative = map[protoreflect.Kind]typeMapper{
	protoreflect.BoolKind:   {"bool", "bool", "false", "DecodeBool", "DecodeRepBool", "EncodeBool", "EncodeRepBool"},
	protoreflect.Int32Kind:  {"int32", "int32", "0", "DecodeInt32", "DecodeRepInt32", "EncodeInt32", "EncodeRepInt32"},
	protoreflect.Sint32Kind: {"int32", "int32", "0", "DecodeSint32", "DecodeRepSint32", "EncodeSint32", "EncodeRepSint32"},
	protoreflect.Uint32Kind: {"uint32", "uint32", "0", "DecodeUint32", "DecodeRepUint32", "EncodeUint32", "EncodeRepUint32"},
	protoreflect.Int64Kind:  {"int64", "int64", "0", "DecodeInt64", "DecodeRepInt64", "EncodeInt64", "EncodeRepInt64"},
	protoreflect.Sint64Kind: {"int64", "int64", "0", "DecodeSint64", "DecodeRepSint64", "EncodeSint64", "EncodeRepSint64"},
	protoreflect.Uint64Kind: {"uint64", "uint64", "0", "DecodeUint64", "DecodeRepUint64", "EncodeUint64", "EncodeRepUint64"},

	protoreflect.Sfixed32Kind: {"int32", "int32", "0", "DecodeSfixed32", "DecodeRepSfixed32", "EncodeSfixed32", "EncodeRepSfixed32"},
	protoreflect.Fixed32Kind:  {"uint32", "uint32", "0", "DecodeFixed32", "DecodeRepFixed32", "EncodeFixed32", "EncodeRepFixed32"},
	protoreflect.Sfixed64Kind: {"int64", "int64", "0", "DecodeSfixed64", "DecodeRepSfixed64", "EncodeSfixed64", "EncodeRepSfixed64"},
	protoreflect.Fixed64Kind:  {"uint64", "uint64", "0", "DecodeFixed64", "DecodeRepFixed64", "EncodeFixed64", "EncodeRepFixed64"},

	protoreflect.FloatKind:  {"float", "float", "0.f", "DecodeFloat", "DecodeRepFloat", "EncodeFloat", "EncodeRepFloat"},
	protoreflect.DoubleKind: {"double", "double", "0.0", "DecodeDouble", "DecodeRepDouble", "EncodeDouble", "EncodeRepDouble"},
	protoreflect.StringKind: {"FBinary", "const FBinary&", "", "DecodeString", "", "EncodeString", ""},
	protoreflect.BytesKind:  {"TArray<uint8>", "const TArray<uint8>&", "", "DecodeByte", "", "EncodeBytes", ""},
}

func ueasParseMessageField(classDef *ClassDef, fd protoreflect.FieldDescriptor, scopeTracker *scopeResolver) {
	var isRepeated = fd.Cardinality() == protoreflect.Repeated
	var formater string = "%s"
	if isRepeated {
		formater = "TArray<%s>"
	}
	fieldInfo := &FieldInfo{
		FieldName: string(fd.Name()),
		Number:    uint64(fd.Number()),
	}

	if n, ok := ueasprotoNative[fd.Kind()]; ok {
		fieldInfo.TypeName = fmt.Sprintf(formater, n.cppType)
		if isRepeated {
			fieldInfo.EncodeMethod = n.encodeRepMethod
			fieldInfo.DecodeMethod = n.decodeRepMethod
		} else {
			fieldInfo.EncodeMethod = n.encodeMethod
			fieldInfo.DecodeMethod = n.decodeMethod
			fieldInfo.DefaultValue = n.zeroValue
		}
	} else {
		if fd.Kind() == protoreflect.MessageKind {

			cppTypeName := scopeTracker.DescopedName(string(fd.Message().FullName()))
			fieldInfo.TypeName = fmt.Sprintf(formater, cppTypeName)

			if isRepeated {
				fieldInfo.EncodeCode = fmt.Sprintf("encoder.EncodeRepSubmessage(%d, %s);",
					fieldInfo.Number, fieldInfo.FieldName)
				fieldInfo.DecodeCode = fmt.Sprintf("decoder.DecodeRepSubmessage(%s_);",
					fieldInfo.FieldName)
			} else {
				fieldInfo.EncodeCode = fmt.Sprintf("encoder.EncodeSubmessage(%d, %s_);",
					fieldInfo.Number, fieldInfo.FieldName)
				fieldInfo.DecodeCode = fmt.Sprintf("decoder.DecodeRepSubmessage(%s_);",
					fieldInfo.FieldName)
			}

		} else if fd.Kind() == protoreflect.EnumKind {

			fieldInfo.TypeName = fmt.Sprintf(formater, string(fd.Enum().FullName()))

		} else {

		}
	}

	classDef.Fields = append(classDef.Fields, fieldInfo)
}

func ueasParseMessageClass(out *ParsedStruct, msg *protogen.Message, scopeTracker *scopeResolver) {
	var newClass *ClassDef = new(ClassDef)
	newClass.ClassName = string(msg.Desc.FullName().Name())

	scopeTracker.ScopeIn(newClass.ClassName)

	newClass.Nested = make([]*ClassDef, 0)
	for _, subMessage := range msg.Messages {
		ueasParseMessageClass(out, subMessage, scopeTracker)
	}

	for _, field := range msg.Fields {
		ueasParseMessageField(newClass, field.Desc, scopeTracker)
	}

	out.ClassDefinations = append(out.ClassDefinations, newClass)

	scopeTracker.ScopeOut()
}

func generateUeas(gen *protogen.Plugin, file *protogen.File) {
	pathStr := file.Desc.Path()
	var baseName string = path.Base(file.Desc.Path())
	baseName = baseName[:len(baseName)-len(filepath.Ext(baseName))]

	OutputDir := path.Join("Protobuf", "ProtobufUEAS", "Source", "Public")
	outputHeader := filepath.Join(OutputDir, baseName+".h")
	outputCpp := filepath.Join(OutputDir, baseName+".cpp")
	scoper := new(scopeResolver)

	pStruct := ParsedStruct{
		SourceFile:  pathStr,
		ProtoName:   baseName,
		PackageName: *file.Proto.Package,
		CppIncludes: []string{
			baseName + ".h",
			"uewire.h",
		},
	}

	outputCppFile, err := os.OpenFile(outputCpp, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		log.Println(err.Error())
		return
	}
	defer outputCppFile.Close()

	outputHeaderFile, err := os.OpenFile(outputHeader, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)
	if err != nil {
		log.Println(err.Error())
		return
	}
	defer outputHeaderFile.Close()

	scoper.ScopeIn(*file.Proto.Package)
	for _, msg := range file.Messages {
		ueasParseMessageClass(&pStruct, msg, scoper)
	}
	scoper.ScopeOut()

	templ, err := template.New("ueash").Parse(ueasHeaderTempl)
	if err != nil {
		log.Fatalln(err)
		return
	}
	templ.Execute(outputHeaderFile, pStruct)

	templ, err = templ.New("ueascpp").Parse(ueasCppTempl)
	if err != nil {
		log.Fatalln(err)
		return
	}
	templ.Execute(outputCppFile, pStruct)

}
