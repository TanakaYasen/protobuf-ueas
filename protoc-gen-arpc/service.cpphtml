// This file is generated by tool, DONT EDIT IT
// Source: [[ {{GetProtoFilePath .}}  ]]

#include <string>

#include "{{GetProtoFileBase .}}.arpc.h"

namespace {{.Proto.Package}} {

using std::string;
// ================================== For server-side use ==================================
{{range .Services}}

{{- $ServiceDirection := .Comments.Leading }}
{{- $ServiceName := UpperIdent .GoName }}
{{- $ServerInterfaceName := print (UpperIdent .GoName) "Implement"}}
{{- $ServerDispatcherName := print (UpperIdent .GoName) "Dispatcher"}}

{{- range .Methods}}
string {{$ServerDispatcherName}}::on{{.GoName}} (const string& data) {
	{{.Input.GoIdent.GoName}} request;
	request.ParseFromString(data);
	{{- if IsNotEmpty .Output.GoIdent.GoName }} 
	string payload;
	{{.Output.GoIdent.GoName}} response;
	implement->{{.GoName}}(request, response);
	response.SerializeToString(&payload);
	return payload;
	{{- else }}
	implement->{{.GoName}}(request);
	{{- end }} 
	return string();
}
{{- end}}

{{ .Comments.Leading -}}
string {{$ServerDispatcherName}}::OnDispatchPackage(const string &name, const string &payload) {
	// server-end has no response
	auto it = (methods.find(name));
	if (it != methods.end()) {
		return it->second(payload);
	}
	return string();
}

{{$ServerDispatcherName}} *{{$ServerDispatcherName}}::Make({{$ServerInterfaceName}} *impl) {
	auto dispatcher = new {{$ServerDispatcherName}}(impl);
	{{- range .Methods}}
	dispatcher->methods.emplace(string("{{.GoName}}"), std::bind(&{{$ServerDispatcherName}}::on{{.GoName}}, dispatcher, std::placeholders::_1));
	{{- end}}
	return dispatcher;
}
{{end}}


// ================================== For client-side use ==================================

{{- range .Services}}
{{- $MessagerName := print (UpperIdent .GoName) "Messager"}}
{{- $MessagerRpcImplement := print (UpperIdent .GoName) "MessagerRpcImplement"}}

{{ range .Methods}}
{{if IsNotEmpty .Output.GoIdent.GoName}}
void {{$MessagerName}}::cb{{.GoName}}(uint32_t seq, const string & content) {
	{{.Output.GoIdent.GoName}} resp;
	resp.ParseFromString(content);
	cbkImpletation->{{.GoName}}(seq, resp);
}
{{ end -}}
{{ end -}}

{{- range .Methods}}
void {{$MessagerName}}::{{ print (PostPrefix .Output.GoIdent.GoName) }}{{.GoName}}(const {{.Input.GoIdent.GoName}} &req) {
	string p;
	req.SerializeToString(&p);
{{- if IsNotEmpty .Output.GoIdent.GoName}}
	auto d = pkgMaker->MakeCallPkg("{{.GoName}}", p);
{{- else }}
	auto d = pkgMaker->MakeSendPkg("{{.GoName}}", p);
{{- end}}
	connection->SendPackage(d);
}
{{- end}}

{{$MessagerName}}  *{{$MessagerName}}::Make({{$MessagerRpcImplement}} *impl, IPkgMaker *pkgMaker, INetConnection *conn) {
	auto msger = new {{$MessagerName}}();
	msger->pkgMaker = pkgMaker;
	msger->cbkImpletation = impl;
	msger->connection = conn;
	return msger;
}

{{end}}
}

