// This file is generated by tool, DONT EDIT IT
// Source: [[ {{GetProtoFilePath .}}  ]]

#include <string>

#include "{{GetProtoFileBase .}}.arpc.h"

namespace {{.Proto.Package}} {

// ================================== 以下供RPC服务端使用 ==================================
{{range .Services}}

{{- $ServiceDirection := .Comments.Leading }}
{{- $ServiceName := UpperIdent .GoName }}
{{- $ServerInterfaceName := print (UpperIdent .GoName) "Implement"}}
{{- $ServerDispatcherName := print (UpperIdent .GoName) "Dispatcher"}}

{{- range .Methods}}
std::string {{$ServerDispatcherName}}::on{{.GoName}} (const std::string& data) {
	{{.Input.GoIdent.GoName}} request;
	request.ParseFromString(data);
	std::string payload;
	{{- if IsNotEmpty .Output.GoIdent.GoName }} 
	{{.Output.GoIdent.GoName}} response;
	implement->{{.GoName}}(request, response);
	response.SerializeToString(&payload);
	{{- else }}
	implement->{{.GoName}}(request);
	{{- end }} 
	return payload;
}
{{- end}}

{{ .Comments.Leading -}}
std::string {{$ServerDispatcherName}}::OnDispatchPackage(const std::string &name, const std::string &payload) {
	// server-end has no response
	auto it = (methods.find(name));
	if (it != methods.end()) {
		return it->second(payload);
	}
	return std::string();
}

{{$ServerDispatcherName}} *Make{{$ServerDispatcherName}}({{$ServerInterfaceName}} *impl) {
	auto dispatcher = new {{$ServerDispatcherName}}();
	return dispatcher;
}
{{end}}


// ================================== 以下供RPC客户端使用 ==================================

{{- range .Services}}
{{- $MessagerName := print (UpperIdent .GoName) "Messager"}}
{{- $MessagerRpcImplement := print (UpperIdent .GoName) "MessagerRpcImplement"}}

{{ range .Methods}}
{{if IsNotEmpty .Output.GoIdent.GoName}}
void {{$MessagerName}}::cb{{.GoName}}(uint32_t seq, const std::string & content) {
	{{.Output.GoIdent.GoName}} resp;
	resp.ParseFromString(content);
	cbkImpletation->{{.GoName}}(seq, resp);
}
{{ end -}}
{{ end -}}

{{- range .Methods}}
void {{$MessagerName}}::{{ print (PostPrefix .Output.GoIdent.GoName) }}{{.GoName}} ({{.Input.GoIdent.GoName}} *req ) {
	std::string p;
	req.SerializeToString(p);
{{- if IsNotEmpty .Output.GoIdent.GoName}}
	auto d = pkgMaker->MakeCallPkg("{{.GoName}}", p, &cb{{.GoName}});
{{ else }}
	auto d = pkgMaker->MakeSendPkg("{{.GoName}}", p);
{{- end}}
	connection->SendPackage(d);
}
{{- end}}

{{$MessagerName}} *Make{{$MessagerName}}({{$MessagerRpcImplement}} *impl , pkgMaker *IPkgMaker, conn INetConnection) {
	return &{{$MessagerName}} {
		cbkImpletation : impl,
		pkgMaker:pkgMaker,
		connection:conn,
	};
}

{{end}}
}

