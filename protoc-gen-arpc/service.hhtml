// This file is generated by tool, DONT EDIT IT
// Source: [[ {{ GetProtoFilePath . }} ]]
#pragma once

#include <map>
#include <cstdint>
#include <string>
#include <functional>
#include "../netlib/netlib.h"
#include "{{GetProtoFileBase .}}.pb.h"

namespace {{.Proto.Package}} {

// ================================== 以下供RPC服务端使用 ==================================
{{range .Services}}

{{- $ServiceDirection := .Comments.Leading }}
{{- $ServiceName := UpperIdent .GoName }}
{{- $ServerInterfaceName := print (UpperIdent .GoName) "Implement"}}
{{- $ServerDispatcherName := print (UpperIdent .GoName) "Dispatcher"}}

// type implements DispatcherImpl is the real reactor
//     and is born for Make{{$ServiceName}}Dispatcher
{{- .Comments.Leading }}
class {{$ServerInterfaceName}}  {
public:
	{{- range .Methods}}
	virtual void {{.GoName}}(const {{.Input.GoIdent.GoName}}& {{ if IsNotEmpty .Output.GoIdent.GoName}}, {{.Output.GoIdent.GoName}}&{{ end }})=0;
	{{- end}}
};

class {{$ServerDispatcherName}}  {
public:
	static {{$ServerDispatcherName}}* Make({{$ServerInterfaceName}} *impl);
	{{$ServerDispatcherName}}({{$ServerInterfaceName}} *_impl):implement(_impl) {}
    std::string Name() const { return "{{$ServerDispatcherName}}"; }
    std::string OnDispatchPackage(const std::string &name, const std::string & payload);
private:
	{{$ServerInterfaceName}} *implement;
    std::unordered_map<std::string, std::function<std::string(const std::string&)>> methods;
private:
    {{- range .Methods }}
    std::string on{{.GoName}} (const std::string &);
    {{- end }}
};
{{end}}

// ================================== 以下供RPC客户端使用 ==================================
{{range .Services}}
{{- $MessagerName := print (UpperIdent .GoName) "Messager"}}
{{- $MessagerRpcImplement := print (UpperIdent .GoName) "MessagerRpcImplement"}}

class {{$MessagerRpcImplement}} {
public:
	{{- range .Methods}}
	{{- if IsNotEmpty .Output.GoIdent.GoName}}
	virtual void {{.GoName}}(uint32_t seq , const {{.Output.GoIdent.GoName}} &resp);
	{{- end}}
	{{- end}}
};

class {{$MessagerName}} {
	{{$MessagerRpcImplement}} *cbkImpletation; 
	IPkgMaker *pkgMaker;
	INetConnection *connection;
public:
	static {{$MessagerName}} *Make({{$MessagerRpcImplement}} *impl, IPkgMaker *pkgMaker, INetConnection *conn);
{{- range .Methods}}
	// rpc {{.GoName}}({{.Input.GoIdent.GoName}}) returns ({{.Output.GoIdent.GoName}})
	void {{ print (PostPrefix .Output.GoIdent.GoName) }}{{.GoName}}(const {{.Input.GoIdent.GoName}} &req);
{{- if IsNotEmpty .Output.GoIdent.GoName}}
	void cb{{.GoName}}(uint32_t seq, const std::string &content);
{{- end}}
{{- end}}
};


{{$MessagerName}} *Make{{$MessagerName}}({{$MessagerRpcImplement}} *impl, IPkgMaker *pkgMaker, INetConnection *conn);
{{end}}

}

