// This file is generated by tool, DONT EDIT IT
// Source: [[ {{ GetProtoFilePath . }} ]]
#pragma once

#include <map>
#include <cstdint>
#include <string>
#include <functional>
#include "../netlib/netlib.h"
#include "{{GetProtoFileBase .}}.pb.h"

namespace {{.Proto.Package}} {

// ================================== 以下供RPC服务端使用 ==================================
{{range .Services}}

{{- $ServiceDirection := .Comments.Leading }}
{{- $ServiceName := UpperIdent .GoName }}
{{- $ServerInterfaceName := print (UpperIdent .GoName) "Implement"}}
{{- $ServerDispatcherName := print (UpperIdent .GoName) "Dispatcher"}}

// type implements DispatcherImpl is the real reactor
//     and is born for Make{{$ServiceName}}Dispatcher
{{- .Comments.Leading }}
class {{$ServerInterfaceName}}  {
public:
	{{- range .Methods}}
	virtual void {{.GoName}}(const {{.Input.GoIdent.GoName}}& {{ if IsNotEmpty .Output.GoIdent.GoName}}, {{.Output.GoIdent.GoName}}&{{ end }})=0;
	{{- end}}
};

class {{$ServerDispatcherName}}  {
public:
	static {{$ServerDispatcherName}}* Make({{$ServerInterfaceName}} *impl);
	{{$ServerDispatcherName}}({{$ServerInterfaceName}} *_impl):implement(_impl) {}
    std::string Name() const { return "{{$ServerDispatcherName}}"; }
    std::string OnDispatchPackage(const std::string &name, const std::string & payload);
private:
	{{$ServerInterfaceName}} *implement;
    std::unordered_map<std::string, std::function<std::string(const std::string&)>> methods;
private:
    {{- range .Methods }}
    std::string on{{.GoName}} (const std::string &);
    {{- end }}
};
{{end}}

// ================================== 以下供RPC客户端使用 ==================================
{{range .Services}}
{{- $MessagerName := print (UpperIdent .GoName) "Messager"}}
{{- $MessagerHelper := print (UpperIdent .GoName) "Helper"}}
{{- $MessagerRpcImplement := print (UpperIdent .GoName) "RpcImplement"}}

class {{$MessagerRpcImplement}} {
public:
	{{- range .Methods}}
	{{- if IsNotEmpty .Output.GoIdent.GoName}}
	virtual void {{.GoName}}(uint32_t seq , const {{.Output.GoIdent.GoName}} &resp) = 0;
	{{- end}}
	{{- end}}
};

template<typename T>
class {{$MessagerHelper}} {
	T* h;
	{{$MessagerRpcImplement}} *cbkImpletation; 
public:
	{{$MessagerHelper}}(T *t, {{$MessagerRpcImplement}} *ci): h(t), cbkImpletation(ci){}
{{- range .Methods}}
	// rpc {{.GoName}}({{.Input.GoIdent.GoName}}) returns ({{.Output.GoIdent.GoName}})
	void {{ print (PostPrefix .Output.GoIdent.GoName) }}{{.GoName}}(const {{.Input.GoIdent.GoName}} &req) {
		string p;
		req.SerializeToString(&p);
{{- if IsNotEmpty .Output.GoIdent.GoName }}
		auto d = h->MakeCallPkg("{{.GoName}}", p);
{{- else }}
		auto d = h->MakeSendPkg("{{.GoName}}", p);
{{- end }}
		h->SendPackage(d);
		return;
	}
{{- if IsNotEmpty .Output.GoIdent.GoName}}
	virtual void cb{{.GoName}}(uint32_t seq, const std::string &content) = 0;
{{- end}}
{{- end}}
};

{{end}}
}

