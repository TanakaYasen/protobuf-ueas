// This file is generated by tool, DONT EDIT IT
// Source: [[ {{ GetProtoFilePath . }} ]]

package {{.GoPackageName}}

import (
	proto "github.com/gogo/protobuf/proto"
	. "protogen/netlib"
)

// ================================== For Server-Side ==================================
{{range .Services}}

{{- $ServiceDirection := .Comments.Leading }}
{{- $ServiceName := UpperIdent .GoName }}
{{- $ServerInterfaceName := print (UpperIdent .GoName) "Implement"}}
{{- $ServerDispatcherName := print (UpperIdent .GoName) "Dispatcher"}}

// type implements DispatcherImpl is the real reactor
//     and is born for Make{{$ServiceName}}Dispatcher
{{- .Comments.Leading }}
type {{$ServerInterfaceName}} interface {
	{{- range .Methods}}
	{{.GoName}} (*{{.Input.GoIdent.GoName}}) {{ if IsNotEmpty .Output.GoIdent.GoName}} *{{.Output.GoIdent.GoName}} {{ end }}
	{{- end}}
}

type {{$ServerDispatcherName}} struct {
	implement {{$ServerInterfaceName}}
	methods map[string]func(data []byte) []byte
}

func (s *{{$ServerDispatcherName}}) Name() string {
	return "{{$ServerDispatcherName}}"
}


{{- range .Methods}}
func (s *{{$ServerDispatcherName}}) on{{.GoName}} (b []byte) []byte {
	var request = {{.Input.GoIdent.GoName}}{}
	err := proto.Unmarshal(b, &request)
	if err != nil {
		return nil
	}
	{{- if IsNotEmpty .Output.GoIdent.GoName }} 
	var response = s.implement.{{.GoName}}(&request)
	d, _ := proto.Marshal(response)
	return d
	{{ else }}
	s.implement.{{.GoName}}(&request)
	return nil
	{{- end }}
}
{{- end}}

{{ .Comments.Leading -}}
func (d *{{$ServerDispatcherName}}) OnDispatchPackage(name string, payload []byte) []byte {
	// server-end has no response
	if method, ok := d.methods[name]; ok {
		{{if eq (GetDirection $ServiceDirection) "s2c"}}
		return method(payload)
		{{else}}
		method(payload)
		return nil
		{{end}}
	}
	return nil
}

func Make{{$ServerDispatcherName}}(impl {{$ServerInterfaceName}}) *{{$ServerDispatcherName}} {
	var dispatcher = new({{$ServerDispatcherName}})
	dispatcher.implement = impl
	dispatcher.methods = make(map[string]func(data []byte) []byte)
	//hard-coded router
	{{- range .Methods}}
	dispatcher.methods["{{.GoName}}"] = dispatcher.on{{.GoName}}
	{{- end}}
	return dispatcher
}
{{end}}


// ================================== For Client-Side ==================================

{{range .Services}}
{{- $MessagerName := print (UpperIdent .GoName) "Messager"}}
{{- $MessagerRpcImplement := print (UpperIdent .GoName) "MessagerRpcImplement"}}

type {{$MessagerRpcImplement}} interface {
	{{- range .Methods}}
	{{if IsNotEmpty  .Output.GoIdent.GoName}}
	{{.GoName}}(sessionId uint32, resp *{{.Output.GoIdent.GoName}})
	{{- end}}
	{{- end}}
}

type {{$MessagerName}} struct {
	cbkImpletation {{$MessagerRpcImplement}}
	pkgMaker 	IPkgMaker
	connection INetConnection
}

{{ range .Methods}}
{{if IsNotEmpty .Output.GoIdent.GoName}}
func (h *{{$MessagerName}}) cb{{.GoName}}(sessionId uint32, content []byte) {
	resp := &{{.Output.GoIdent.GoName}}{}
	proto.Unmarshal(content, resp)
	h.cbkImpletation.{{.GoName}}(sessionId, resp)
}
{{ end -}}
{{ end -}}

{{range .Methods}}
func (h *{{$MessagerName}}) {{ print (PostPrefix .Output.GoIdent.GoName) }}{{.GoName}} (req *{{.Input.GoIdent.GoName}}) {
	p, _ := proto.Marshal(req)
{{- if IsNotEmpty .Output.GoIdent.GoName}}
	d := h.pkgMaker.MakeCallPkg("{{.GoName}}", p, h.cb{{.GoName}})
{{ else }}
	d := h.pkgMaker.MakeSendPkg("{{.GoName}}", p)
{{- end}}
	h.connection.SendPackage(d)
}
{{end}}

func Make{{$MessagerName}}(impl {{$MessagerRpcImplement}}, pkgMaker IPkgMaker, conn INetConnection) *{{$MessagerName}} {
	return &{{$MessagerName}} {
		cbkImpletation : impl,
		pkgMaker:pkgMaker,
		connection:conn,
	}
}

{{end}}
